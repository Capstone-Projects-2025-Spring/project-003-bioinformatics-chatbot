"use strict";(self.webpackChunkcreate_project_docs=self.webpackChunkcreate_project_docs||[]).push([[6244],{21926:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var s=n(74848),i=n(28453);const o={sidebar_position:1},r="Unit tests",a={id:"testing/unit-testing",title:"Unit tests",description:"Katerina: for my tests I selected pytest because it works with Flask\u2019s built",source:"@site/docs/testing/unit-testing.md",sourceDirName:"testing",slug:"/testing/unit-testing",permalink:"/project-003-bioinformatics-chatbot/docs/testing/unit-testing",draft:!1,unlisted:!1,editUrl:"https://github.com/Capstone-Projects-2025-Spring/project-003-bioinformatics-chatbot/edit/main/documentation/docs/testing/unit-testing.md",tags:[],version:"current",lastUpdatedBy:"Khanh Nguyen",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"docsSidebar",previous:{title:"Test Procedures",permalink:"/project-003-bioinformatics-chatbot/docs/category/test-procedures"},next:{title:"Integration tests",permalink:"/project-003-bioinformatics-chatbot/docs/testing/integration-testing"}},c={},d=[{value:"Backend",id:"backend",level:2},{value:"Library",id:"library",level:3},{value:"Frontend",id:"frontend",level:2},{value:"Library",id:"library-1",level:3}];function l(t){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",...(0,i.R)(),...t.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h1,{id:"unit-tests",children:"Unit tests"}),"\n",(0,s.jsx)(e.p,{children:"Katerina: for my tests I selected pytest because it works with Flask\u2019s built\nin test client to simulate HTTP requests, and this was necessary for multiple\nbackend tests that I conducted. For instance, the test_chat_message_valid(client)\ntest verifies that the /chat route correctly handles requests. Additionally,\npytest also enabled me to conduct error handling. In test_chat_message_missing(client),\nI test for a 400 bad request error when no message is provided, ensuring the API properly\nhandles invalid input. Additionally, I used pytest with the libraries io\nand werkzeug to simulate uploading a pdf file in test_upload_pdf_valid(client, app)."}),"\n",(0,s.jsx)(e.h2,{id:"backend",children:"Backend"}),"\n",(0,s.jsx)(e.h3,{id:"library",children:"Library"}),"\n",(0,s.jsx)(e.p,{children:"Pytest was chosen for backend testing due to its seamless integration with\nFlask. For test coverage we are using Coverage.py in order to monitor pytest execution\nand get insights regarding untested code paths. Each function and route will be tested\nvia pytest on the backend, including unit tests for individual functions."}),"\n",(0,s.jsxs)(e.p,{children:["To run tests\n",(0,s.jsx)(e.code,{children:"python -m pytest -vv"})]}),"\n",(0,s.jsx)(e.h2,{id:"frontend",children:"Frontend"}),"\n",(0,s.jsx)(e.h3,{id:"library-1",children:"Library"}),"\n",(0,s.jsx)(e.p,{children:"We are using Vitest for frontend testing in React. Vitest was chosen due to its fast execution,\nbuilt-in support for React-Vite projects, and strong compatibility with component testing libraries.\nEach component will have tests associated with it, thereby allowing us to test funtctional and UI aspects\nof each component."}),"\n",(0,s.jsxs)(e.p,{children:["To run tests\n",(0,s.jsx)(e.code,{children:"cd frontend && npm run test"})]})]})}function u(t={}){const{wrapper:e}={...(0,i.R)(),...t.components};return e?(0,s.jsx)(e,{...t,children:(0,s.jsx)(l,{...t})}):l(t)}},28453:(t,e,n)=>{n.d(e,{R:()=>r,x:()=>a});var s=n(96540);const i={},o=s.createContext(i);function r(t){const e=s.useContext(o);return s.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function a(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(i):t.components||i:r(t.components),s.createElement(o.Provider,{value:e},t.children)}}}]);