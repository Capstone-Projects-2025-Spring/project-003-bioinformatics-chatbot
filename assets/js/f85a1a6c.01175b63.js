"use strict";(self.webpackChunkcreate_project_docs=self.webpackChunkcreate_project_docs||[]).push([[6244],{21926:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>l,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var s=n(74848),i=n(28453);const o={sidebar_position:1},r="Unit tests",a={id:"testing/unit-testing",title:"Unit tests",description:"Backend",source:"@site/docs/testing/unit-testing.md",sourceDirName:"testing",slug:"/testing/unit-testing",permalink:"/project-003-bioinformatics-chatbot/docs/testing/unit-testing",draft:!1,unlisted:!1,editUrl:"https://github.com/Capstone-Projects-2025-Spring/project-003-bioinformatics-chatbot/edit/main/documentation/docs/testing/unit-testing.md",tags:[],version:"current",lastUpdatedBy:"JustinTruong456",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"docsSidebar",previous:{title:"Test Procedures",permalink:"/project-003-bioinformatics-chatbot/docs/category/test-procedures"},next:{title:"Integration tests",permalink:"/project-003-bioinformatics-chatbot/docs/testing/integration-testing"}},d={},c=[{value:"Backend",id:"backend",level:2},{value:"Library",id:"library",level:3},{value:"Frontend",id:"frontend",level:2},{value:"Library",id:"library-1",level:3}];function h(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"unit-tests",children:"Unit tests"}),"\n",(0,s.jsx)(t.h2,{id:"backend",children:"Backend"}),"\n",(0,s.jsx)(t.h3,{id:"library",children:"Library"}),"\n",(0,s.jsx)(t.p,{children:"Pytest was chosen for backend testing due to its seamless integration with\nFlask. For test coverage we are using Coverage.py in order to monitor pytest execution\nand get insights regarding untested code paths. Each function and route will be tested\nvia pytest on the backend, including unit tests for individual functions."}),"\n",(0,s.jsxs)(t.p,{children:["To run tests\n",(0,s.jsx)(t.code,{children:"python -m pytest -vv"})]}),"\n",(0,s.jsx)(t.h2,{id:"frontend",children:"Frontend"}),"\n",(0,s.jsx)(t.h3,{id:"library-1",children:"Library"}),"\n",(0,s.jsx)(t.p,{children:"We are using Vitest for frontend testing in React. Vitest was chosen due to its fast execution,\nbuilt-in support for React-Vite projects, and strong compatibility with component testing libraries.\nEach component will have tests associated with it, thereby allowing us to test funtctional and UI aspects\nof each component."}),"\n",(0,s.jsxs)(t.p,{children:["To run tests\n",(0,s.jsx)(t.code,{children:"cd frontend && npm run test"})]}),"\n",(0,s.jsx)(t.p,{children:"Katerina: for my tests I selected pytest because it works with Flask\u2019s built\nin test client to simulate HTTP requests, and this was necessary for multiple\nbackend tests that I conducted. For instance, the test_chat_message_valid(client)\ntest verifies that the /chat route correctly handles requests. Additionally,\npytest also enabled me to conduct error handling. In test_chat_message_missing(client),\nI test for a 400 bad request error when no message is provided, ensuring the API properly\nhandles invalid input. Additionally, I used pytest with the libraries io\nand werkzeug to simulate uploading a pdf file in test_upload_pdf_valid(client, app)."}),"\n",(0,s.jsx)(t.p,{children:"Justin: For my testings, I chose pytest because how it easily and efficiently test variables\nand support HTTP requests testing. For the testing of my parse_pdf, the test case test_parse_pdf(pdf)\naccepts a PDF file, parses it into chunks, and store in a list. Test_parse_pdf is expected to return\na list containing the parsed chunks. Futhermore, I use pytest to test the intergration of uploading,\nparsing, and indexing. The test case test_integration(client, app) is testing for 400 bad request error after\ninvaild request is made. The test case test_integration(client, app) also verifies that a valid request\nsuccessfully completes the entire workflow\u2014uploading, parsing, and indexing\u2014and returns a 200 OK status code."}),"\n",(0,s.jsx)(t.p,{children:"Keith: For my testing, I chose Vitest because of its seamless integration with testing libraries and its speed. My test's focus was to make sure that the Chat History's download button behaved properly under three different conditions. Those three conditions were that an error message arises when there are zero messages, allowing the user to download the conversation when there is at least one message, and the proper file format (.txt, .doc, or .pdf) is being downloaded. My testing was done under download.test.jsx, which is located in the tests folder in the frontend directory. All tests first simulate the user clicking the download button which allows them to select the file format. The first three tests verify that when the user clicks on the three different file formats, an error message arises since no conversation has been started. The next three tests verify that if there is at least one conversation started, then the chat history is downloaded with the correct file format."}),"\n",(0,s.jsx)(t.p,{children:'Troy: Backend tests I have written consist of testing functionality for the User model for the database and sqlalchemy,\ntesting the testing configuration and client, testing the function to return the score for langchain with pg vector.\nWe have chosed pytest for the backend due to it being the defacto standard for flask testing due to its easily integration\nof clients and mocking. Frontend tests I have written/ modified consist of the chat response testing, this was modified\nfor to ensure that upon submit the "spinner" is shown on the screen and is gone upon response or error.'})]})}function l(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var s=n(96540);const i={},o=s.createContext(i);function r(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);